# PHP: увеличение потребление памяти при использовании "лишних" переменных

Программистам может показаться интересным лишь теоретически и совсем немного.

И правильно: как правило, зачем заморачиваться на мелочах в ущерб читаемости.

На новой работе мне сказали, что можно совсем чуть 
**выиграть в производительности** простым образом - **без необходимости не создавать переменную**.

Я же думал, что в простых случаях Zend будет умнее меня - и не сделает лишний переменных в компилируемом C-коде.

Опытов на самом деле с разными примерами было еще больше, но привел результаты лишь 2 примеров кода.

Понятное дело - большее потребление памяти потенциально влечет к лишней работе сборщика мусора, чем тоже в большинстве
случаев можно пренебречь.

## TLDR: Вывод

Так и есть. Как бы очевидным это не было:

**Не смотря, на оптимизации с новыми выпусками PHP даже на простом коде разница в производительности будет.**

В каждом проведенном мной опыте при создании переменной, даже если она используется 1 раз и в следующей строке -
потребление памяти увеличивается.

Да, скорее незначительная, но вам виднее на сколько это приемлемо для вашего приложения.

## Пример А

Например, результат функции сразу засунуть в новую функцию без создания переменной (это я более наглядный вариант
привожу), типа:

### Код (№1) без переменной

```php
<?php
function f2(): string { return ' -'; }
function f1(string $string): string { return $string . "> "; }
echo PHP_VERSION . ": " . memory_get_usage();
echo f1(f2()); // Более эффективно
echo memory_get_usage();
```

### Код (№2) с переменной

Дальше я запускал такой же скрипт, но вместо `echo f1(f2());` заменил на 2 строки с созданием переменной

```php
<?php
function f2(): string { return ' -'; }
function f1(string $string): string { return $string . "> "; }
echo PHP_VERSION . ": " . memory_get_usage();
$foo = f2(); // Объявлена переменная
echo f1($foo); // Чуть менее эффективно
echo memory_get_usage();
```

### Результаты кода (№1) без переменной

Вот результаты вывода скрипта, запущены локально на разных ПХП:

7.3.33: 473080 -> 473112

8.1.29: 402184 -> 402216

8.2.20: 598608 -> 598640

8.3.8: 631368 -> 631400

### Результаты кода (№2) с переменной

7.3.33: 473376 -> 473408

8.1.29: 402608 -> 402640

8.2.20: 598776 -> 598808

8.3.8: 631536 -> 631568

## Пример Б

Основу примера взял с quora: https://qr.ae/psaASm (изменил совсем незначительно)

### Без использования переменной
```php
<?php
function getUser() { return ['email' => 'someone@example.com']; }
function sendEmail($email) { return; }

echo phpversion() . ": " . memory_get_usage() . " -> ";
sendEmail(getUser()['email']);
echo memory_get_usage();
```

8.3.8: 633904 -> 633904

8.2.20: 601144 -> 601136

8.1.29: 404848 -> 404840

7.3.33: 476192 -> 476144


### C использованием переменной

```php
<?php
function getUser() { return ['email' => 'someone@example.com']; }
function sendEmail($email) { return; }

echo phpversion() . ": " . memory_get_usage() . " -> ";
$user = getUser();
$email = $user['email'];
sendEmail($email);
echo memory_get_usage();
```

8.3.8: 634112 -> 634112

8.2.20: 601352 -> 601344

8.1.29: 405056 -> 405048

7.3.33: 476464 -> 476416
